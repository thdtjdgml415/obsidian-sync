![쿠키를 발급받고 사용하는 과정](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/9489d7be-1dc2-4938-b9e3-99bc808dc4ad/Untitled.png)

쿠키를 발급받고 사용하는 과정

HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠키 또는 세션을 사용한다.

기본적으로 HTTP 통신은 `connectionless`, `stateless`한 특성을 가지고 있기 때문에 서버와 클라이언트는 통신을 할때 항상 누구인지 확인하는 과정이 필요하다.

이 특성을 보완하기 위해 쿠키와 세션을 사용

connectionless, stateless

|connectionless|stateless|
|---|---|
|클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징|통신이 끝나면 연결을 유지하지 않는다|
|HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라인언트에게 요청에 맞는 response를 보내고 접속을 끊는 특성|연결을 끊는 순간 클라이언트와 서버 통신이 끝나면 상태 정보는 유지하지 않는 특성|
|헤더에 keep-alive라는 값을 줘서 커넥션을 재활용하는데 HTTP1.1에서는 이것이 디폴트다.|쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용|
|HTTP가 tcp위에서 구현되었기 때문에 (tcp는 연결지향,udp는 비연결지향) 네트워크 관점에서 keep-alive는 옵션으로 connectionless의 연결비용을 줄이는 것을 장점으로 비연결지향이라 한다.|쿠키와 세션을 사용했을 경우, 한 번 로그인을 하면 어떠한 방식에 의해서 그 사용자에 대한 인증을 유지|

## 쿠키

### 쿠키란?

- 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
- 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시산이 정해지면 브라우저가 종료되어도 인증이 유효
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조
- 클라이언트에 300개까지 쿠키에 저장 가능, 하나의 도메인당 20개의 값만 가짐, 하나의 쿠키는 4kb
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키 생성가능
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header을 넣어서 자동으로 서버에 전송

### 쿠키의 구성요소

- 이름: 각각의 쿠키의 고유이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

### 쿠키의 동작 방식

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관
5. 같은 요청을 할 경우 HTTP헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 떄 쿠키를 업데이트 하여 변경된 쿠키를 HTTP헤더에 포함시켜 전달

## 추천 배경지식

`현재 브라우저에서 사용되는 쿠키 정책`,  `쿠키의 옵션`,  `HTTP 요청 헤더 설정값`

`현재 브라우저에서 사용되는 쿠키 정책` : 프론트엔드에 set-cookie를 설정할때 중요한 지식으로 브라우저가 쿠키를 설정하는 주체이기 때문에, 해당 브라우저의 쿠키 정책에 따라 코드를 작성해야한다.(* 알아둘 필요가 있음)

`쿠키의 옵션` : 백엔드와 프론트엔드 간에 네트워크 통신으로 쿠키를 주고 받을 때 중요하다. CORS를 회피하기 위해 각 경우에 쿠키 옵션을 설정해주어야 한다.

`HTTP 요청 헤더 설정값` : 클라이언트에서 네트워크 요청을 보낼 때, 백엔드와 프론트엔드 도메인 자원공유를 위해 필요, 이 역시 CORS를 회피하기 위한 옵션으로 HTTP요청 헤더의 `withCredentials` 속성을 설정해야 백엔드에서 HTTP 트랜잭션에 포함시킨 쿠키 값이나 인증 정보를 정상적으로 주고 받는다

## 이해해야 할 쿠키의 옵션

- `secure` : 이 값이 true로 설정되다면, https 환경에서만 쿠키를 주고 받을 수 있다. 만약 https가 아니라면 네트워크에 다음과 같이 표시된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/b2d69502-d529-46d9-b80e-ce3bd33817f6/Untitled.png)

- `SameSite` : 서로 다른 도메인간의 쿠키 전송에 대한 보안을 설정한다. 로컬 개발 환경에서 백엔드 서버와 쿠키를 주고 받는다면 둘의 도메인이 다르므로 `SameSite=None` 옵션을 사용하게 되는데, 이를 사용하기 위해서는 `secure` 쿠키 사용이 강제된다. 이에 대한 설명은 아래의 `**현재 브라우저에서 사용되는 쿠키 정책**` 에서 더 자세히하겠다.
- `path` : 쿠키가 사용되는 URL 경로를 지정한다. 이 속성을 `/` 로 지정해야 모든 페이지에서 쿠키를 사용할 수 있다.
- `Expires/Max-Age` :쿠키의 만료 날짜 또는 최대 사용기간을 설정한다. NEXT.js 와 같은 서버 사이드에서 쿠키를 제어 할 때, Set-Cookie와 해당 옵션을 이용하여 쿠키를 삭제할 수 있다.

## 현재 브라우저에서 사용되는 쿠키 정책 (sameSite, secure cookie)

크롬 80버전 (2020년 2월 4일 이후) 부터 새로운 쿠키정책이 적용되어, Cookie의 SameSite 속성의 기본 값이 none에서 Lax로 변경, 이는 쿠키의 CSRF 문제를 해결하기 위해 탄생하였는데,

CSRF란 “HTTP 트랜잭션에서 자동으로 붙어나가는 쿠키를 탈취하여 쿠키에 들어있는 사용자 정보나 권한을 악용하는 것” 으로 요약할 수 있다.

이러한 공격을 막기 위해 SameSite 정책 등장

- `SameSite=Strict` : 쿠키가 같은 도메인 내에서만 전송
- `SameSite=Lax` : 동일한 도메인이 아닌 경우에도 일부 요청에 대해서는 쿠키를 전송한다. 예를 들어 `GET`과 같은 안전한 메서드를 사용한 요청이거나 `a href`, `link href`를 사용하는 경우에 쿠키를 전송
- `SameSite = None` : 다른 도메인에 대한 요청의 경우(크로스 사이트 요청) 에도 쿠키가 전송된다.

그러나 백엔드 api서버의 도메인과 클라이언트의 도메인이 다른 일이 많으므로 SameSite 설정이 보수적으로 설정된가면 사용자의 경험에 영향을 줄 수 있다. 따라서 SameSite=None 옵션을 사용하되, 이옵션을 통하여 주고 받는 쿠키에 secure을 설정하는 것을 강제하여 HTTPS요청에서만 쿠키를 주고 받게 한다.

이를 통하여 HTTPS를 통한 모든 응답과 그에 붙어나가는 쿠키 역시 HTTPS가 제공하는 암호화에 의하여 암호화된다. 따라서 중간에 쿠키를 가져가서 쿠키에 들어있는 유저 정보를 가져가려고 해도 암호화되어있기 때문에 확인할 수 없는 것이다.

## CORS 회피하기

쿠키 옵션 설정의 경우, 백엔드 - 클라이언트 양쪽의 설정이 필요

### 1. 백엔드 설정: `set-Cookie` 헤더에 노출 (`exposedHeader`)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/96db9946-1ab3-4383-9350-982726ba6049/Untitled.png)

클라이언트에서 쿠키를 정상적으로 받기 위해 백엔드에서 (`exposedHeaders` 설정)을 해주어야한다. 백엔드에서 클라이언트에 쿠키를 설정해 줄 때 HTTP 응답 Header를 사용하여 설정하게 되고, 클라이언트는 이 Header을 사용하여 클라이언트 앱에서 쿠키를 설정하게 되는데 위의 설정이 없다면 클라이언트에서 읽을 수 있는 HTTP응답 헤더의 값이 제한되기 때문에 정상적으로 Set-cookie와 같은 헤더를 읽을 수 없다.